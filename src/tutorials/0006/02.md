By using a cryptographic algorithm to generate the hash, we guarantee that we can identify a file with a single hash.

But some algorithms stopped being compliant with the previously stated rules (`sha1` for example), and further more, with time, other algorithms might too not be enough for the purpose of content addressing in IPFS.
For this reason, and also to be able to support multiple cryptographic algorithms, **we need to be able to know which algorithm was used to generate the hash** of specific content.

![What is the hashing algorithm used in a hash?](tutorial-assets/T0006L02-what-algo.jpg)

So how can we do this?
To support multiple hashing algorithms, we use **Multihash**.

## Multihash format

A [**multihash**](https://multiformats.io/multihash/) is basically a self-describing hash, meaning, itself contains the metadata that describes what cryptographic algorithm generated the hash and its length.
By using multihash IPFS becomes future-proof by not relying on specific hashing algorithms because it **supports multiple hashing algorithms**.

Multihashes follow the `TLV` pattern (`type-length-value`). Essentially, the "original hash" is prefixed with a `type` and the `length` of the hash.

![Multihash format](tutorial-assets/T0006L02-multihash.jpg)

 - `type`: identifier of the **cryptographic algorithm** used to generate the hash (e.g. the identifier of `sha2-256` would be `18` - `0x12` in hexadecimal. see the [multicodec table](https://github.com/multiformats/multicodec/blob/master/table.csv) for all the identifiers)
 - `length`: the actual **length** of the hash (using `sha2-256` it would be `256`)
 - `value`: the actual **hash value**

To be able to have a compact string form representation of a CID (instead of plain binary), IPFS uses `base58btc` encoding to get the following:

`QmY7Yh4UquoXHLPFo2XbhXkhBvFoPwmQUSa92pxnxjQuPU`

So with this full specification, the first version of CIDs was born! This first version is called version zero: `CIDv0`.
The initial `Qm...` characters are easily spotted on version zero (`CIDv0`) CIDs.

Although, with time, doubts about whether this format would be enough or not started to come up:

 - How do we know what encoding is data represented on?
 - How do we know what is the encoding of the string version of the hash represented on - will we always be using `base58btc`?

Because of these questions, an evolution to the initial version of a CID was necessary.
In the next lessons we will explore what was added to the CID specification that made into the new CID version: `CIDv1`.
