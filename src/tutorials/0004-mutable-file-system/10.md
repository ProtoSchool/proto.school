---
    title: "Read the contents of a file"
    type: "file-upload"
---

MFS has a [`files.read`](https://github.com/ipfs/interface-js-ipfs-core/blob/master/SPEC/FILES.md#filesread) method that allows you to display the contents of a file in a *buffer*. This allows us to easily read the contents of a `.txt` file among others.

The method takes this format:

```js
ipfs.files.read(path, [options])
```

The `path` provided is the path of the file to read, and it must point to a file rather than a directory.

The `files.read` method returns an Async Iterable, that iterates over the file's chunks of data, i.e. Buffers, which can be converted to a string using the method `toString('utf8')`. For example:

```js
const concat = require('it-concat')

let bufferedContents = await concat(ipfs.files.read('/directory/some-file.txt'))  // a buffer
let contents = bufferedContents.toString('utf8') // a string
```

or

```js
const concat = require('it-concat')

let contents = (await concat(ipfs.files.read('/directory/some-file.txt'))).toString('utf8') // a string
// notice the parentheses around the entire await statement
```

When you're ready to try this in the real world, you should note that the above example can result in heavy memory usage, depending on the contents of the file being read. If you find this to be the case, you might want to skip the usage of the `it-concat` package and process each chunk of data iteratively.
This is the main reason why ipfs returns `Async Iterables` so that we can decide if we want to be aware of memory performance issues or not.
But in ProtoSchool tutorials, we don't really need to worry about this since our code challenges will use small files, so we can concatenate everything without worrying about performance.
