---
    title: "Read the contents of a file"
    type: "file-upload"
---

MFS has a [`files.read`](https://github.com/ipfs/interface-js-ipfs-core/blob/master/SPEC/FILES.md#filesread) method that allows you to display the contents of a file in a *buffer*. This allows us to easily read the contents of a `.txt` file among others.

The method takes this format:

```js
ipfs.files.read(path, [options])
```

The `path` provided is the path of the file to read, and it must point to a file rather than a directory.

The `files.read` method returns an Async Iterable that iterates over the file's chunks of data, i.e. Buffers, which can be converted to a string using the method `toString('utf8')`. For example:

```js
import concat from 'it-concat'

let bufferedContents = await concat(ipfs.files.read('/directory/some-file.txt'))  // a buffer
let contents = bufferedContents.toString() // a string
```

You might be wondering what the `concat` function is.
Since we need to concatenate all the chunks of data and then convert the data to a string, we need a way to iterate over all the values and put them together one by one. To do this, we can use the [`it-concat`](https://www.npmjs.com/package/it-concat) package.
The final data returned is of type `Buffer` and so to get the data as a string, we then need to call the method `toString()` and we're done.

When you're ready to try this in the real world, you should note that the above example can result in heavy memory usage, depending on the contents of the file being read. If you're working with large files and find this to be the case, you might want to skip using the `it-concat` package and instead process each chunk of data iteratively. The main reason IPFS now returns `Async Iterables` is to provide a built-in option for dealing with potential performance issues.
In ProtoSchool tutorials, our code challenges use small files, so we can concatenate everything without worrying about performance.
